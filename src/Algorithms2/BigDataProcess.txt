是不是没有搞ACM就心里感觉不如人？那么看看如下的帖子吧
http://www.zhihu.com/question/21451231

TopK问题

搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。
假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3
百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查
询串，要求使用的内存不能超过1G。

针对此类典型的TOP K问题，采取的对策往往是：HashMap + 堆。如下所示：

1：先用HashMap统计出每条记录出现的次数,HashMap(Query,Value),如果记录不在HashMap中,那么就
把这个记录加1,如果该字符串在HashMap中,则把值增1,最终在O(n)时间内完成了统计

2:堆排序,借助堆这个数据结构,找出TopK,时间复杂度为O(nlgk),维护一个大小为k的的小根堆。
然后遍历300万的记录,每次和小根堆的堆顶元素进行比较,如果比堆顶元素大,则交换,然后再维
护好堆。


海量数据分布在100台电脑中，想个办法高效统计出这批数据出现次数的TOP10。

 如果每个数据元素只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素
 为什么呢？因为。
 就拿2台机器求Top2来说，第一台机器：a(50),b(50),c(49),d(49)
 					  第二台机器：a(0),b(0),c(49),d(49)
 这样的话,如果按照下面的方法是会出错的。第一台,top2为a b.第二台,top2为c d 最后汇总起来的top2
 还是为a b，正确的其实为c d

对每一台电脑选出前10,先HashMap统计出现的次数,然后用堆进行解决选出每台电脑的top10
对100台电脑分别的top10(SUM 1000),然后把这1000个数据组合起来。再用堆排序求出top10

这个时候，你可以有两种方法：
遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，
统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。